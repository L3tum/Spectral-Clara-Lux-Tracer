//
//  AreaLight.cpp
//  Spectral Clara Lux tracer
//
//  Created by Fabrizio Duroni on 31/10/15.
//  Copyright © 2015 Fabrizio Duroni. All rights reserved.
//

#include "pch.h"
#include "MaterialBRDF.hpp"
#include "AreaLight.hpp"

AreaLight::AreaLight(Point3D origin,
                     Spectrum<constant::spectrumSamples>
                     lightSpectrum, float radius) : Light(origin, lightSpectrum) {

    setupAreaLight(origin, radius);
}

AreaLight::AreaLight(Point3D origin, Vector3D color, float radius) : Light(origin, color) {
    
    setupAreaLight(origin, radius);
}

void AreaLight::setupAreaLight(const Point3D& origin, float radius) {
    
    //Sphere light.
    //We assign a fake material (posssible improvement: emissive material)
    lightSphere = new Sphere(origin, radius, true);
    lightSphere->material = MaterialBRDF::emissiveMaterial(spectrum);
    
    //Seed random generator.
    unsigned seed = (int)std::chrono::system_clock::now().time_since_epoch().count();
    generator.seed(seed);
    
    generateRandomPointsOnSphere();
}

Vector3D AreaLight::generateRandomSphereUnitVector() {
    
    std::uniform_real_distribution<float> distribution(0.0f, 1.0f);

    //Generate random theta.
    float theta = distribution(generator) * 2.0f * constant::pi;

    //Generate random x.
    float x = (distribution(generator) * 2.0f) - 1.0f;

    //A uniformly distributed point can be generated by
    //choosing z uniformly distributed on –1 to +1, and
    //x and y uniformly distributed on a circle of
    //sqrt(radius 1 – z^2). Graphics gem III pag. 126.
    float circleRadius = sqrt(1.0f - powf(x, 2.0f));

    //Create random vector.
    Vector3D randomUnitVector(x, circleRadius * cos(theta), circleRadius * sin(theta));

    return randomUnitVector;
}

void AreaLight::generateRandomPointsOnSphere() {

    for (int i = 0; i < constant::numberOfShadowRay; i++) {
        
        Vector3D randomUniVector = generateRandomSphereUnitVector();
        Point3D randomPointOnSphere = lightSphere->center + (randomUniVector * lightSphere->radius);
        randomSpherePoints.push_back(randomPointOnSphere);
    }
}

AreaLight::~AreaLight() {
    
    delete lightSphere;
}
